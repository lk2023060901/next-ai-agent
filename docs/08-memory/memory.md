# Agent 记忆与认知系统

## 1 记忆体系架构

### 1.1 设计原则

单纯的 RAG 检索本质上是**被动的关键词/语义匹配**，无法让 Agent 真正"记住"和"理解"。完整的 Agent 记忆系统需要模拟人类记忆的多层结构：

| 记忆类型 | 人类类比 | 时效 | 作用 |
|----------|---------|------|------|
| 工作记忆 | 工作记忆 (Working Memory) | 当前会话 | 当前对话上下文、中间推理状态 |
| 短期记忆 | 短期记忆 (Short-term) | 小时~天 | 近期交互摘要、临时偏好 |
| 长期记忆 | 长期记忆 (Long-term) | 永久 | 用户偏好、项目知识、历史决策 |
| 情景记忆 | 情景记忆 (Episodic) | 永久 | 具体事件回忆：谁在何时做了什么 |
| 语义记忆 | 语义记忆 (Semantic) | 永久 | 抽象知识：概念、关系、规则 |
| 程序记忆 | 程序记忆 (Procedural) | 永久 | 如何做：工作流、操作模式 |
| 共享记忆 | 团队知识 | 永久 | 跨 Agent 共享的组织级知识 |

### 1.2 记忆系统总体架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          Agent 认知层                                    │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │                      记忆协调器 (Memory Orchestrator)              │  │
│  │  负责决定：何时写入、读取哪种记忆、如何合并多源记忆、记忆权重排序     │  │
│  └──────┬──────────┬──────────┬──────────┬──────────┬───────────────┘  │
│         │          │          │          │          │                   │
│    ┌────▼────┐┌────▼────┐┌────▼────┐┌────▼────┐┌────▼────┐           │
│    │工作记忆  ││短期记忆  ││长期记忆  ││情景记忆  ││共享记忆  │           │
│    │(Context)││(Buffer) ││(Core)   ││(Episode)││(Shared) │           │
│    └────┬────┘└────┬────┘└────┬────┘└────┬────┘└────┬────┘           │
└─────────┼──────────┼──────────┼──────────┼──────────┼────────────────┘
          │          │          │          │          │
     ┌────▼────┐┌────▼────┐┌────▼──────────▼────┐┌────▼────┐
     │ Redis   ││ Redis   ││     Milvus         ││PostgreSQL│
     │ (会话   ││ (TTL    ││  (向量检索)         ││ (结构化  │
     │  上下文) ││  缓存)  ││                    ││  存储)   │
     └─────────┘└─────────┘└────────────────────┘└─────────┘
                                    │
                              ┌─────▼─────┐
                              │   MinIO    │
                              │ (原始文件)  │
                              └───────────┘
```

---

## 2 各记忆层详细设计

### 2.1 工作记忆 (Working Memory)

**本质**：当前对话的滑动窗口上下文 + Agent 推理的中间状态。

#### 2.1.1 上下文窗口管理

| 策略 | 描述 |
|------|------|
| 滑动窗口 | 保留最近 N 条消息 (默认 50 条) |
| Token 预算 | 动态计算，为模型保留 max_tokens 的 70% 给上下文 |
| 优先级保留 | 系统提示词 > 用户最新消息 > 工具调用结果 > 历史对话 |

#### 2.1.2 上下文压缩方案

当对话长度接近 Token 预算时，触发多级压缩：

**第 1 级 — 消息裁剪** (Token 使用 > 60%)：
- 移除工具调用的完整输出，仅保留摘要结果
- 移除重复的系统提示 (仅保留最新版本)
- 图片/附件替换为文字描述

**第 2 级 — 渐进式摘要** (Token 使用 > 75%)：
- 将较早的对话分段 (每 10 条消息为一段)
- 调用 LLM 对每段生成摘要 (使用轻量模型如 Haiku)
- 摘要格式：`[摘要] 用户讨论了 X，Agent 决定了 Y，关键结论是 Z`
- 最近 10 条消息保持原文，更早的替换为摘要

**第 3 级 — 关键信息提取** (Token 使用 > 90%)：
- 对所有历史摘要再次压缩为单个 "会话概要"
- 提取结构化信息：决策列表、待办事项、关键约定
- 仅保留概要 + 最近 5 条原文消息

```
原始对话 (200条, 50K tokens)
    │ 第1级裁剪
    ▼
裁剪后 (200条, 35K tokens)
    │ 第2级摘要
    ▼
摘要区 (15段摘要, 3K tokens) + 最近10条原文 (5K tokens) = 8K tokens
    │ 第3级提取
    ▼
会话概要 (1段, 800 tokens) + 最近5条原文 (2.5K tokens) = 3.3K tokens
```

**压缩触发时机**：
- 发送消息前自动检测
- 异步压缩 (不阻塞用户输入)
- 压缩结果缓存在 Redis (TTL = 会话存活时间)

#### 2.1.3 中间推理状态

Agent 执行多步任务时的 Scratchpad：

```json
{
  "session_id": "sess_xxx",
  "scratchpad": {
    "current_goal": "实现用户注册功能",
    "sub_goals": ["设计数据库表", "实现 API", "编写测试"],
    "completed": ["设计数据库表"],
    "current_step": "实现 API",
    "decisions": [
      { "what": "使用 bcrypt 加密密码", "why": "安全性最佳实践" }
    ],
    "blockers": []
  }
}
```

存储位置：Redis Hash，TTL = 会话超时时间 (默认 30 分钟无活动过期)

### 2.2 短期记忆 (Short-term Buffer)

**本质**：跨会话但有时效的记忆缓冲层。

#### 2.2.1 触发写入

每次会话结束或达到一定轮次时，自动从工作记忆中提取：

```
会话结束
    │
    ▼
[记忆提取 Agent] (使用 LLM 提取)
    │
    ├─→ 用户偏好变化？ → 写入短期记忆 (TTL 7天)
    ├─→ 新的项目决策？ → 写入短期记忆 (TTL 7天)
    ├─→ 待跟进事项？ → 写入短期记忆 (TTL 3天)
    └─→ 情感/态度信号？ → 写入短期记忆 (TTL 1天)
```

#### 2.2.2 存储结构

Redis Sorted Set，score = 时间戳 + 重要性权重：

```
memory:short:{workspaceId}:{agentId} → SortedSet [
  { score: 1708300000.9, value: JSON.stringify({ type, content, source, expires }) }
]
```

#### 2.2.3 晋升机制

短期记忆中被多次访问或被显式确认的条目，自动晋升为长期记忆：

| 条件 | 动作 |
|------|------|
| 被检索 ≥ 3 次 | 晋升为长期语义记忆 |
| 用户显式确认 ("记住这个") | 立即晋升为长期记忆 |
| TTL 到期且未被访问 | 自然淘汰 |
| 与已有长期记忆冲突 | 更新长期记忆版本 |

### 2.3 长期记忆 (Long-term Core)

**本质**：持久化的核心知识，分为三个子系统。

#### 2.3.1 语义记忆 (Semantic Memory)

存储抽象知识和概念关系：

```json
{
  "id": "mem_xxx",
  "type": "semantic",
  "category": "user_preference",
  "content": "用户偏好使用 TypeScript + React 技术栈",
  "confidence": 0.95,
  "evidence_count": 12,
  "first_observed": "2026-01-15T10:00:00Z",
  "last_confirmed": "2026-02-18T08:00:00Z",
  "related_memories": ["mem_yyy", "mem_zzz"],
  "tags": ["tech_stack", "preference"]
}
```

存储：Milvus (向量检索) + PostgreSQL (结构化元数据)

#### 2.3.2 情景记忆 (Episodic Memory)

存储具体事件的时间线：

```json
{
  "id": "ep_xxx",
  "type": "episodic",
  "event": "用户报告了登录页面的 CSS 布局问题",
  "context": {
    "session_id": "sess_123",
    "participants": ["user_abc", "agent_frontend"],
    "outcome": "修复了 flex 布局导致的按钮错位",
    "artifacts": ["fix_commit_sha"]
  },
  "timestamp": "2026-02-17T14:30:00Z",
  "importance": 0.7
}
```

存储：PostgreSQL (时间序列查询) + Milvus (语义检索)

#### 2.3.3 程序记忆 (Procedural Memory)

存储 Agent 学习到的操作模式和工作流：

```json
{
  "id": "proc_xxx",
  "type": "procedural",
  "name": "用户偏好的代码审查流程",
  "trigger": "当用户请求代码审查时",
  "steps": [
    "1. 先检查代码风格和命名规范",
    "2. 重点关注安全漏洞 (SQL注入、XSS)",
    "3. 检查错误处理是否完善",
    "4. 最后给出改进建议，不要直接修改"
  ],
  "success_rate": 0.92,
  "usage_count": 15,
  "last_updated": "2026-02-18T10:00:00Z"
}
```

存储：PostgreSQL (结构化) + Redis (热点缓存)

### 2.4 共享记忆 (Shared Memory)

**本质**：跨 Agent 共享的工作区级知识。

#### 2.4.1 共享记忆类型

| 类型 | 写入方 | 读取方 | 示例 |
|------|--------|--------|------|
| 项目上下文 | 协调 Agent | 所有 Agent | "项目使用 monorepo 结构" |
| 架构决策记录 (ADR) | 架构 Agent | 开发/测试 Agent | "选择 PostgreSQL 而非 MySQL 因为..." |
| 代码约定 | 审查 Agent | 开发 Agent | "函数命名使用 camelCase" |
| 已知问题 | 测试 Agent | 开发/运维 Agent | "生产环境存在内存泄漏" |
| 用户偏好 | 任意 Agent | 所有 Agent | "用户希望回复简洁" |

#### 2.4.2 共享记忆协议

- **写入**：Agent 写入共享记忆前需经协调 Agent 批准 (防止冲突)
- **冲突解决**：时间戳最新 + 置信度最高的版本优先
- **可见性**：工作区内所有 Agent 可读，仅创建者和协调 Agent 可修改
- **存储**：PostgreSQL `shared_memories` 表 + Milvus 向量索引

---

## 3 记忆检索策略

### 3.1 多路召回 (Multi-path Recall)

Agent 在生成回复前，同时从多个记忆源召回相关信息：

```
用户消息输入
    │
    ▼
┌──────────────────────────────────────────────────────────┐
│                  记忆协调器 (并行召回)                       │
│                                                           │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐         │
│  │ 向量语义检索│  │ 关键词检索  │  │ 时间衰减检索│         │
│  │ (Milvus)   │  │ (PG全文)   │  │ (最近N天)  │         │
│  │ Top-K=10   │  │ Top-K=10   │  │ Top-K=5    │         │
│  └─────┬──────┘  └─────┬──────┘  └─────┬──────┘         │
│        │               │               │                  │
│  ┌─────▼───────────────▼───────────────▼──────┐          │
│  │            RRF 融合排序 (Reciprocal Rank)    │          │
│  └─────────────────────┬──────────────────────┘          │
│                        │                                  │
│  ┌─────────────────────▼──────────────────────┐          │
│  │            重排序 (Reranking)                │          │
│  │  - 相关性得分                                │          │
│  │  - 时间衰减权重 (越新越重要)                  │          │
│  │  - 记忆类型权重 (程序>语义>情景)              │          │
│  │  - 置信度权重                                │          │
│  │  - 使用频次权重                              │          │
│  └─────────────────────┬──────────────────────┘          │
│                        │                                  │
│                   Top-K=5 最终结果                         │
└────────────────────────┼──────────────────────────────────┘
                         │
                         ▼
              注入到 Agent 的系统提示词中
```

### 3.2 记忆注入格式

检索到的记忆以结构化方式注入 Agent 提示词：

```
<memory>
  <user_preferences>
    - 偏好 TypeScript + React 技术栈 (置信度: 95%, 来源: 12次对话)
    - 希望代码注释使用中文 (置信度: 88%)
  </user_preferences>

  <project_context>
    - 项目使用 Next.js 15 + HeroUI + TailwindCSS
    - 数据库: PostgreSQL 16
    - 架构决策: 采用微服务架构 (ADR-003, 2026-02-10)
  </project_context>

  <recent_episodes>
    - [2天前] 修复了登录页面布局问题 (flex 错位)
    - [5天前] 完成了用户注册 API 开发
  </recent_episodes>

  <relevant_procedures>
    - 代码审查流程: 风格检查 → 安全审计 → 改进建议
  </relevant_procedures>
</memory>
```

### 3.3 自适应检索

根据消息意图动态调整检索策略：

| 意图分类 | 主要检索路径 | 辅助路径 |
|----------|-------------|---------|
| 新任务 | 语义记忆 (相关知识) | 程序记忆 (操作模式) |
| 追问/澄清 | 工作记忆 (上下文) | 情景记忆 (历史事件) |
| Bug 修复 | 情景记忆 (类似问题) | 知识库 (文档) |
| 偏好相关 | 语义记忆 (偏好) | 短期记忆 (最新偏好) |
| 跨 Agent 任务 | 共享记忆 | 目标 Agent 的程序记忆 |

---

## 4 Token 优化策略

### 4.1 总体策略

| 策略 | 节省比例 | 适用场景 |
|------|---------|---------|
| 上下文渐进式压缩 | 40-70% | 长对话 |
| 记忆摘要代替原文 | 60-80% | 历史上下文注入 |
| 轻量模型做预处理 | 省 Opus Token | 记忆提取/摘要/分类 |
| 按需检索替代全量注入 | 50-90% | 记忆注入 |
| 工具结果精简 | 30-50% | 工具调用返回 |
| 共享上下文去重 | 20-30% | 多 Agent 协作 |

### 4.2 模型分层调用

不同任务使用不同模型以优化成本：

| 任务 | 模型选择 | 原因 |
|------|---------|------|
| 核心推理/创作 | Claude Opus 4.6 | 需要最强能力 |
| 代码生成/编辑 | Claude Sonnet 4.5 | 性价比最优 |
| 上下文压缩/摘要 | Claude Haiku 4.5 | 轻量快速 |
| 记忆提取/分类 | Claude Haiku 4.5 | 结构化任务 |
| 向量 Embedding | text-embedding-3-small | 专用模型 |
| 意图分类 | Claude Haiku 4.5 | 分类任务 |
| 记忆重排序 | Cohere Rerank / BGE Reranker | 专用排序模型 |

### 4.3 缓存策略

| 缓存层 | 存储 | TTL | 命中率预估 |
|--------|------|-----|-----------|
| Embedding 缓存 | Redis | 24h | 60%+ (重复查询) |
| 记忆检索结果缓存 | Redis | 5min | 30% (同会话多次) |
| 压缩摘要缓存 | Redis | 会话生命周期 | 90%+ |
| 系统提示词模板缓存 | 内存 | 进程生命周期 | 99%+ |

---

## 5 知识库 (RAG 子系统)

RAG 是记忆系统的**一个子模块**，专门处理外部文档知识的检索：

### 5.1 知识库管理页面

**路由**: `/org/[slug]/ws/[workspace-slug]/knowledge`

*（页面结构同原设计，此处省略重复内容，见原文 Section 2）*

### 5.2 增强 RAG 策略

在基础 RAG 之上叠加以下增强：

#### 5.2.1 查询改写 (Query Rewriting)

用户原始查询 → LLM 改写为多个检索友好的查询：

```
原始: "怎么修那个登录的 bug"
改写:
  1. "登录页面 bug 修复方案"
  2. "用户认证错误排查"
  3. "login authentication error fix"
```

#### 5.2.2 假设文档嵌入 (HyDE)

LLM 先生成一个"假设的理想答案"，用该答案的向量去检索，而非用问题本身：

```
问题: "如何优化数据库查询性能？"
HyDE 假设答案: "数据库查询优化可以从索引优化、查询计划分析、连接池配置、读写分离四个方面入手..."
→ 用假设答案的向量去 Milvus 检索，命中率更高
```

#### 5.2.3 父文档检索 (Parent Document Retrieval)

检索到的 chunk 同时返回其所属的上下级 chunk，提供更完整的上下文：

```
检索命中 chunk #5
    → 同时返回 chunk #4 (前文) + chunk #5 + chunk #6 (后文)
    → 以及 chunk #5 所属的父级 section 标题
```

#### 5.2.4 自动总结索引 (Summary Index)

对每个文档生成多层次摘要：

```
文档级摘要 → Section 级摘要 → Chunk 级内容
```

检索时先匹配文档/Section 摘要，再深入到 Chunk 级别，减少噪声。

---

## 6 记忆管理页面

### 6.1 记忆总览页

**路由**: `/org/[slug]/ws/[workspace-slug]/memory`

**Tabs**: 全部记忆 | 语义记忆 | 情景记忆 | 程序记忆 | 共享记忆 | 知识库

**搜索**: 支持自然语言语义搜索 + 标签筛选 + 时间范围

每条记忆卡片:
```
┌──────────────────────────────────────────────────────────┐
│ [记忆类型图标] [类型Badge]        [置信度: 95%] [3天前]    │
│                                                           │
│ 用户偏好使用 TypeScript + React 技术栈                      │
│ (Body, 2行截断)                                           │
│                                                           │
│ 来源: 12次对话 · Agent: 协调Agent · 标签: tech_stack       │
│ (Caption, Text-Tertiary)                                  │
│                                           [编辑] [删除]    │
└──────────────────────────────────────────────────────────┘
```

记忆类型图标与颜色:
- 语义: Brain (Purple)
- 情景: Clock (Blue)
- 程序: Workflow (Green)
- 共享: Users (Amber)

### 6.2 记忆健康度面板

位于记忆页面顶部:

```
┌──────────────┐ ┌──────────────┐ ┌──────────────┐ ┌──────────────┐
│ 总记忆条数    │ │ 平均置信度    │ │ 过期记忆      │ │ 冲突记忆      │
│ 234          │ │ 87%          │ │ 12 (待清理)   │ │ 3 (待解决)   │
└──────────────┘ └──────────────┘ └──────────────┘ └──────────────┘
```

- "过期记忆" 点击: 打开清理确认 Modal
- "冲突记忆" 点击: 打开冲突解决界面 (选择保留哪个版本)
